#include <ntddk.h>

typedef struct
{
	PDEVICE_OBJECT 	NextLayerDeviceObject; // 다음계층의 DeviceObject
	PDEVICE_OBJECT 	PhysicalDeviceObject;  // DeviceStack의 PDO
	PDEVICE_OBJECT 	DeviceObject;		   // SIMPLE드라이버의 FDO
	UNICODE_STRING	UnicodeString;		   // 응용프로그램과 연결될 이름
}DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#include "devioctl.h"
#include <initguid.h>

DEFINE_GUID(GUID_SIMPLE, 
0x5665dec0, 0xa40a, 0x11d1, 0xb9, 0x84, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x62);

#define SIMPLEIOCTLBASE		       0xA00
#define IOCTL_SIMPLE_CONTROL	CTL_CODE(FILE_DEVICE_UNKNOWN, SIMPLEIOCTLBASE, METHOD_BUFFERED, FILE_ANY_ACCESS)
// 응용프로그램측에서 DeviceIoControl() API를 호출할때 사용하는 IOControlCode

NTSTATUS
SIMPLE_AddDevice
	(
	IN PDRIVER_OBJECT DriverObject,         
	IN PDEVICE_OBJECT PhysicalDeviceObject  
	)
{
	NTSTATUS returnStatus = STATUS_SUCCESS;         
	PDEVICE_OBJECT DeviceObject = NULL;             
	PDEVICE_EXTENSION deviceExtension;

	returnStatus = IoCreateDevice                                       
					(                                               
						DriverObject,                               
						sizeof ( DEVICE_EXTENSION ),                
						NULL,                   
						FILE_DEVICE_UNKNOWN,
						FILE_AUTOGENERATED_DEVICE_NAME,                                          
						FALSE,                                      
						&DeviceObject       
					);// DeviceObject를 생성합니다

	if( !NT_SUCCESS( returnStatus ) )
	{
		goto SIMPLE_AddDevice_Exit;
	}

	deviceExtension = DeviceObject->DeviceExtension;
	RtlZeroMemory( deviceExtension, sizeof(DEVICE_EXTENSION));
	deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
	deviceExtension->DeviceObject = DeviceObject;

	deviceExtension->NextLayerDeviceObject =
		IoAttachDeviceToDeviceStack (
								DeviceObject,
								PhysicalDeviceObject	
		);
	// 디바이스 스택에 연결합니다

	DeviceObject->Flags |= deviceExtension->NextLayerDeviceObject->Flags & 
							( DO_POWER_PAGABLE  | DO_POWER_INRUSH); 
	DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING; 

	IoRegisterDeviceInterface( PhysicalDeviceObject, &GUID_SIMPLE, NULL, &deviceExtension->UnicodeString );
	// 응용프로그램이 접근할 수 있는 이름을 생성합니다

SIMPLE_AddDevice_Exit:
	return returnStatus;
}

/*
CompleteRoutine작성법중 STATUS_MORE_PROCESSING_REQUIRED 를
리턴하는 형태를 보여줍니다
*/
NTSTATUS
SIMPLE_DeferIrpCompletion
	(
	IN PDEVICE_OBJECT DeviceObject,     
	IN PIRP Irp,                        
	IN PVOID Context                    
	)
{
	PKEVENT event = Context;    
	
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	KeSetEvent(event,
			   1,
			   FALSE); // SIMPLE_PnpDispatch 측에서 KeWaitForSingleObject()에게 시그널합니다
	
	return STATUS_MORE_PROCESSING_REQUIRED; 
}

/*
Pnp Manager로 부터 전달되는 PnP Event IRP를 받습니다
*/
NTSTATUS
SIMPLE_PnpDispatch
	(
	IN PDEVICE_OBJECT DeviceObject,   
	IN PIRP Irp                       
	)
{
	PIO_STACK_LOCATION pStack;                
	PDEVICE_EXTENSION deviceExtension;        
	NTSTATUS returnStatus = STATUS_SUCCESS;   
	PDEVICE_OBJECT NextLayerDeviceObject;     
	
	pStack = IoGetCurrentIrpStackLocation ( Irp );
	deviceExtension = DeviceObject->DeviceExtension;
	NextLayerDeviceObject = deviceExtension->NextLayerDeviceObject;
			
	switch ( pStack->MinorFunction )
	{
		case IRP_MN_START_DEVICE : // 디바이스스택이 구동상태로 변했다는 사실을 알려줍니다
		{	// 후처리시나리오를 시작합니다
			KEVENT event; 
			KeInitializeEvent(&event, NotificationEvent, FALSE);
			IoCopyCurrentIrpStackLocationToNext(Irp);  
			IoSetCompletionRoutine(Irp,
								   SIMPLE_DeferIrpCompletion,
								   &event,
								   TRUE,
								   TRUE,
								   TRUE); // CompletionRoutine 을 설정합니다
			
			returnStatus = IoCallDriver(NextLayerDeviceObject,Irp); // 후처리이므로 먼저 다음계층으로 IRP를 보냅니다
			if (returnStatus == STATUS_PENDING) 
			{
				KeWaitForSingleObject(
					&event,
					Executive,
					KernelMode,
					FALSE,
					NULL); // SIMPLE_DeferIrpCompletion 함수에서 시그널하는 이벤트를 기다립니다
				returnStatus = Irp->IoStatus.Status;
			}
			if( !NT_SUCCESS( returnStatus ) )
			{
				IoCompleteRequest( Irp, IO_NO_INCREMENT );
				goto SIMPLE_PnpDispatch_Exit;
			}

			/*
				주의할점은, 지금 상태에서 IRP의 현재 스택은 SIMPLE드라이버의 것으로 되어있습니다
			*/

			// 응용프로그램이 연결될 이름을 허용합니다. Win32 CreateFile() 함수를 사용할 수 있습니다
			IoSetDeviceInterfaceState( &deviceExtension->UnicodeString, TRUE ); 

			// IRP를 완료요청합니다
			IoCompleteRequest( Irp, IO_NO_INCREMENT ); 
		}	
		break;

		case IRP_MN_REMOVE_DEVICE :
		{	// DeviceStack이 해제된다는 사실을 알려줍니다
			// 선처리시나리오를 시작합니다
			
			// 응용프로그램이 연결될 이름을 금지합니다.
			IoSetDeviceInterfaceState( &deviceExtension->UnicodeString, FALSE );

			// 응용프로그램 연결에 사용된 이름메모리를 해제합니다
			RtlFreeUnicodeString( &deviceExtension->UnicodeString );

			// 현재 디바이스 스택으로 부터 연결되어있던 FDO를 끊습니다
			IoDetachDevice ( NextLayerDeviceObject );

			// FDO를 제거합니다
			IoDeleteDevice ( DeviceObject );
			Irp->IoStatus.Status = STATUS_SUCCESS;

			// 현재 IRP의 스택을 다음 계층의 드라이버를 위해서 포기합니다
			IoSkipCurrentIrpStackLocation( Irp );

			// 선처리가 모두 끝났으므로 다음 계층의 드라이버에게 IRP를 보냅니다
			returnStatus = IoCallDriver(NextLayerDeviceObject, Irp);
		}
		break;

		default:
		{
			// 나머지 Pnp IRP명령어는 모두 관심을 가지지 않고 다음 계층으로 소유권을 넘깁니다
			IoSkipCurrentIrpStackLocation( Irp ); 
			returnStatus = IoCallDriver(NextLayerDeviceObject, Irp);
		}
		break;
	} 

SIMPLE_PnpDispatch_Exit:

	return returnStatus;
}

/*
Power Manager로 부터 전달되는 Power Event IRP를 받습니다
특별한 처리는 하지 않고 받은 모든 명령어를 다음 계층으로 전달하도록 합니다
*/
NTSTATUS                                                            
SIMPLE_PowerDispatch
	(                                                               
		IN PDEVICE_OBJECT DeviceObject,                             
		IN PIRP Irp                                                 
	)
{
	PDEVICE_EXTENSION		deviceExtension;
	NTSTATUS returnStatus;
	PDEVICE_OBJECT NextLayerDeviceObject;           
	
	deviceExtension = DeviceObject->DeviceExtension;
	NextLayerDeviceObject = deviceExtension->NextLayerDeviceObject;

	// 또 다른 Power IRP명령어를 받을 수 있다는 사실을 Power Manager에게 알립니다
	PoStartNextPowerIrp( Irp ); 

	// Power IRP의 소유권을 다음 계층을 위해서 포기합니다
	IoSkipCurrentIrpStackLocation( Irp ); 

	// PoCallDriver를 사용하는것을 유의하세요
	returnStatus = PoCallDriver(NextLayerDeviceObject, Irp); 
	
	return returnStatus;
} 

// 드라이버가 메모리에서 해제될때 호출됩니다
VOID                                                                
SIMPLE_Unload                                                       
	(                                                               
	IN PDRIVER_OBJECT DriverObject 
	)
{
	UNREFERENCED_PARAMETER(DriverObject);

}

// 응용프로그램이 CreateFile() API를 사용하면 연결됩니다
NTSTATUS                                                            
SIMPLE_Create
	(                                                               
		IN PDEVICE_OBJECT DeviceObject,                             
		IN PIRP Irp                                                 
	)
{
	NTSTATUS returnStatus = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = returnStatus; // 성공적인 처리를 알립니다
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return returnStatus;
} 

/*
응용프로그램이 DeviceIoControl() API를 사용하는 경우, 
파라미터로 사용되는 IOControlCode값을 확인하고 있다
*/
NTSTATUS                                                            
SIMPLE_DeviceIoControl
	(                                                               
		IN PDEVICE_OBJECT DeviceObject,                             
		IN PIRP Irp                                                 
	)
{
	PIO_STACK_LOCATION pStack;
	NTSTATUS returnStatus = STATUS_UNSUCCESSFUL;
	ULONG ulIoControlCode;
	PVOID pInputBuffer, pOutputBuffer;
	ULONG ulInputBufferLength, ulOutputBufferLength;
	ULONG_PTR Information = 0;

	UNREFERENCED_PARAMETER(DeviceObject);

	/*
	잘못된 파라미터가 전달되었는지를 확인하는 목적으로 필요한 변수값들을 모두 가져옵니다
	*/
	pStack = IoGetCurrentIrpStackLocation( Irp );
	ulInputBufferLength = pStack->Parameters.DeviceIoControl.InputBufferLength;
	ulOutputBufferLength = pStack->Parameters.DeviceIoControl.OutputBufferLength;
	ulIoControlCode = pStack->Parameters.DeviceIoControl.IoControlCode;
	pInputBuffer = pOutputBuffer = Irp->AssociatedIrp.SystemBuffer;

	switch( ulIoControlCode )
	{
		case IOCTL_SIMPLE_CONTROL: // 응용프로그램이 사용한 IOControlCode를 확인합니다
			returnStatus = STATUS_SUCCESS; // 지금은 별다른 처리없이 성공으로 완료합니다
			Information = 0;
			break;
	}

	Irp->IoStatus.Information = Information;
	Irp->IoStatus.Status = returnStatus;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return returnStatus;
}

// 응용프로그램이 CloseHandle()함수를 호출하면 연결됩니다
NTSTATUS                                                            
SIMPLE_Close
	(                                                               
		IN PDEVICE_OBJECT DeviceObject,                             
		IN PIRP Irp                                                 
	)
{
	NTSTATUS returnStatus = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = returnStatus;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return returnStatus;
} 

// 드라이버가 메모리에 상주할때 호출됩니다
NTSTATUS                                                            
DriverEntry                                                         
	(                                                               
	IN PDRIVER_OBJECT DriverObject,             
	IN PUNICODE_STRING RegistryPath             
							
	)
{
	NTSTATUS returnStatus = STATUS_SUCCESS;    

	UNREFERENCED_PARAMETER(RegistryPath);

	DriverObject->DriverUnload = SIMPLE_Unload; // 드라이버가 메모리에서 해제될때 호출되는 곳
	DriverObject->DriverExtension->AddDevice = SIMPLE_AddDevice; // DeviceStack이 형성될때 호출되는 곳
	DriverObject->MajorFunction[IRP_MJ_PNP] = SIMPLE_PnpDispatch; // Pnp Manager가 전달하는 IRP를 수신하는 곳
	DriverObject->MajorFunction[IRP_MJ_POWER] = SIMPLE_PowerDispatch; // Power Manager가 전달하는 IRP를 수신하는 곳
	DriverObject->MajorFunction[IRP_MJ_CREATE] = SIMPLE_Create; // Win32 API CreateFile()과 연결
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = SIMPLE_Close; // Win32 API CloseHandle()과 연결
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SIMPLE_DeviceIoControl; // Win32 API DeviceIoControl()과 연결

	return returnStatus;
}

